# tac_plus-ng sample configuration — Keycloak + Vault failover chain
#
# Order-independent chain: either module can be first or second.
# The example below shows Keycloak (primary) → Vault (break-glass fallback),
# but swapping the order works identically.
#
# Keycloak handles normal user authentication via ROPC. If Keycloak cannot
# verify the user (ERROR) or the user doesn't exist there (NOTFOUND), the
# request falls through to Vault. Similarly, if Vault doesn't have the user
# (NOTFOUND) or encounters an error (ERROR), it falls through to Keycloak.
#
# MAVIS chain mechanics (see mavis_glue.c:fixup_result()):
#   - FAIL (NAK) is ALWAYS terminal — there is no "action fail" directive.
#     Only used for definitive denials (wrong password for a known user,
#     missing required group).
#   - ERROR (ERR) is terminal by default. "action error = continue" converts
#     it to MAVIS_DOWN, passing the request to the next module.
#   - NOTFOUND (NFD) with the default "action not-found = continue" also
#     becomes MAVIS_DOWN, passing to the next module.
#   - Set "action error = continue" on BOTH modules so either can be first.
#     When a module is last in the chain, fixup_result() is a no-op — its
#     ERROR/NOTFOUND verdicts are terminal regardless of the action setting.
#
# NOTE on setenv and execve:
#   libmavis_external.c (line ~701-704) uses execve() when ANY "setenv" is
#   present, which replaces the entire process environment. The child process
#   gets ONLY the explicitly listed setenv vars — no PATH, PYTHONPATH,
#   LD_LIBRARY_PATH, etc. Even a single setenv triggers this.
#
#   For containerized deployments, the simplest approach is to use ZERO setenv
#   directives and instead pass ALL variables via Docker env_file or -e flags.
#   With no setenv, the child inherits the full container environment
#   (including PYTHONPATH set in the Dockerfile), and the scripts read their
#   config via os.getenv() either way.
#
#   If you must use setenv (e.g. bare-metal, no container), you need to list
#   every variable the child needs — including PATH and PYTHONPATH.
#
# Keycloak prerequisites:
#   1. Create a client with "Direct Access Grants" (ROPC) enabled
#   2. Add a "Group Membership" protocol mapper to include groups in the token:
#      Client > Client scopes > dedicated scope > Add mapper > By type >
#      "Group Membership" — set Token Claim Name to "groups", Full group path OFF
#   3. Create groups in Keycloak matching the group names below
#
# Vault prerequisites:
#   1. Enable KV v2 at the configured mount point (default: secret/)
#   2. Create an AppRole with read access to the user secrets path
#   3. Store user secrets:
#      vault kv put secret/tacacs/users/admin password=s3cret groups=admin,noc
#      vault kv put secret/tacacs/users/breakglass password=emergency groups=admin
#
# Docker usage:
#   docker run \
#     -v $PWD/tac_plus-ng-keycloak-vault.cfg:/etc/tac_plus-ng/tac_plus-ng.cfg \
#     --env-file tacplus.env \
#     -p 49:49 ghcr.io/marcinpsk/tacplus-ng

id = spawnd {
	listen { port = 49 }
	spawn {
		instances min = 1
		instances max = 10
	}
}

id = tac_plus-ng {

	# Keycloak MAVIS backend (primary) #####################################
	mavis module keycloak = external {
		exec = /usr/local/lib/mavis/mavis_tacplus_keycloak.py
		# Required: KEYCLOAK_URL (script will refuse to start without it)
		# setenv KEYCLOAK_URL = https://keycloak.example.com
		# setenv KEYCLOAK_REALM = myrealm
		# setenv KEYCLOAK_CLIENT_ID = tacacs
		# setenv KEYCLOAK_CLIENT_SECRET = changeme
		# setenv KEYCLOAK_VERIFY_TLS = 1
		# setenv KEYCLOAK_REQUIRE_GROUP = tacacs-users

		# Allow chaining: on ERROR (Keycloak down, timeout, or invalid_grant
		# which conflates wrong-password with user-not-found), pass to the
		# next module. Has no effect when this is the last module in chain.
		action error = continue
	}

	# Vault MAVIS backend (break-glass fallback) ############################
	mavis module vault = external {
		exec = /usr/local/lib/mavis/mavis_tacplus_vault.py
		# Required: VAULT_ADDR, VAULT_ROLE_ID, VAULT_SECRET_ID
		# setenv VAULT_ADDR = https://vault.example.com:8200
		# setenv VAULT_ROLE_ID = <role-id>
		# setenv VAULT_SECRET_ID = <secret-id>
		# setenv VAULT_MOUNT = secret
		# setenv VAULT_PATH_PREFIX = tacacs/users
		# setenv VAULT_VERIFY_TLS = 1
		# setenv VAULT_CACHE_TTL = 300
		# setenv VAULT_REDIS_CACHE_TTL = 600

		# Allow chaining: on ERROR (Vault unreachable, auth failure), pass
		# to the next module. Has no effect when this is the last module
		# in chain. Both modules have this so order can be swapped freely.
		action error = continue
	}

	user backend = mavis
	login backend = mavis
	pap backend = mavis

	# Devices ###############################################################
	host world {
		address = 0.0.0.0/0
		address = ::/0
		# REQUIRED: uncomment and set a strong shared secret
		# key = changeme
		enable 15 = login
	}

	# Profiles ##############################################################
	profile admin {
		script {
			if (service == shell) {
			    if (cmd == "") {
				set priv-lvl = 15
				permit
			    }
			    permit
			}
		}
	}

	profile engineering {
		enable 15 = login
		script {
			if (service == shell) {
			    if (cmd == "") {
				set priv-lvl = 15
				permit
			    }
			    permit
			}
		}
	}

	profile readonly {
		script {
			if (service == shell) {
			    if (cmd == "") {
				set priv-lvl = 1
				permit
			    }
			    if (cmd =~ /^show/) permit
			    deny
			}
		}
	}

	# Groups (matched by Keycloak/Vault group membership) ##################
	group admin { }
	group engineering { }
	group readonly { }
	# "noc" appears in Vault examples but is not mapped to a profile here.
	# Users whose only group is noc will be denied by the ruleset below.
	# To grant noc access, add a profile and a ruleset branch for it.

	# Ruleset ###############################################################
	ruleset {
		rule default {
			enabled = yes
			script {
				if (member == admin) {
					profile = admin
					permit
				}
				if (member == engineering) {
					profile = engineering
					permit
				}
				if (member == readonly) {
					profile = readonly
					permit
				}
				# Deny users not matching any known group
				deny
			}
		}
	}
}
